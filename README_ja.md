# ranunculus

適当にまとめたC++ライブラリ

## types.hpp
`<cstdint>`, `<cstddef>`あたりからプリミティブ型をranunculus名前空間に放り込むためのもの

## utility.hpp
以下の物が定義される

* `enable_when`
* `RANUNCULUS_EXCEPT_WHEN`マクロ

## integer\_sequence.hpp
`std::integer_sequence` 風のテンプレートクラスに対しての拡張。
よくある配列に対する操作をテンプレートクラスの実体化に対して使える。

* `append`: 末尾に可変個の値を追加する
* `prepend`: 先頭に可変個の値を追加する
* `concat`: 可変個のクラスを結合する
* `at`: インデックスを指定して値を取り出す
* `slice`: 指定した範囲を切り出す
* とか。後で書く

## type\_sequence.hpp
`std::tuple`など、可変長型配列に対する拡張。
内容はinteger\_sequence.hppのものとほぼ共通。

## bitcount.hpp
`popcount`, `nlz`, `ntz`などのビット操作を定数式で実装。scoped enum型にも対応

## compare.hpp
いくつかの比較演算子が実装されていれば無理やり比較をする。
比較する対象が同一の型の場合、`<`, `<=`, `>=`, `>`のいずれか一つが実装されていれば比較可能。
異なる型の場合、２つの比較演算子が実装されていればよい（ただし、`==`と`!=`, `<`と`>=`, `>`と`<=`の組み合わせは不可）
ADLで解決できる演算子が定義されている場合、そちらをより優先的に使用する。
パフォーマンス上の懸念がある場合、`<`, `==`, `>`の3種（もしくはそれらと結果が逆になるもの）を定義しておけば良い。

## arith.hpp
scalar型に対し、同一サイズの整数型とみなして算術演算を行う。

## operators.hpp
算術演算子および比較演算子を自動定義する。


